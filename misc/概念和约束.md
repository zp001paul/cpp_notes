# 概念和约束

## 好文章

https://zhuanlan.zhihu.com/p/452566841 # 这篇才是入门好文章

## 其他材料

1. mq-b的模板课程
2. 极客时间的c++20课程

## concept是个啥玩意

其实concept就是个bool常量！
证明如下：

```c++
template <typename MyType>
concept Any = true;

std::cout << std::boolalpha <<  Any<int> << std::endl; // 输出 true
```

## 约束是个什么玩意

首先，约束 != requires
有三种约束

1. 合取式
2. 析取式
3. 原子约束
   其中第一、二种，直接使用concept xxx = std::is_same_v<T1, T2>这种语法
   第三种才采用requires表达式的语法

## requires关键字是个什么玩意

首先要区分两个东西，不然很乱的

1. requires如果出现在concept的定义之中，被成为requires表达式
2. requires如果出现在template关键字之后，函数之前，被成为requires子句
   两者是不同的，区别在于:
3. requires表达式：就是一个返回bool的编译期函数，是一个谓词
4. requires子句： requires是个关键字，告诉编译器后面是一个返回bool的编译器运行的函数 或者 直接的常量表达式

### requires表达式

requires表达式是用在概念的定义部分
它的作用是用来结合编译器的功能，产生一个返回bool的编译期运行的函数
requires表达式有以下形式

```txt
1. 第一种形式
{/*表达式，结尾不要有分号*/} -> /*noexcept 可选*/ /*表达式应当满足的concept*/;
2. 第二种形式
x+y; // 这种简单的表达式
```

我们可以这样使用

```c++
template <typename ScalarType>
concept Field = requires(ScalarType x, ScalarType y)
{
    {x + y} -> std::same_as<ScalarType>; // same_as需要两个参数，为什么这里填入一个参数就行？应该是编译器帮我们填了一个额外的参数：decltype(x+y)
    {x - y} -> std::same_as<ScalarType>;
    {+x} -> std::same_as<ScalarType>;
    {-x} -> std::same_as<ScalarType>;
    ScalarType(0);

    {x * y} -> std::same_as<ScalarType>;
    {x / y} -> std::same_as<ScalarType>;
    ScalarType(1);
};
```

### requires子句

字面上的特征就是：两个requires关键字连用
requires子句是用在模板函数里面，它表达了模板参数应该在什么条件下工作

```c++
export template <typename T1, typename  T2>
    requires requires (T1 x, T2 y) { x + y; }
std::common_type<T1, T2> func(
    T1 arg1, T2 arg2
) {
    return arg1 + arg2;
}
```
