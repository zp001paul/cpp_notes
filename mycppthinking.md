# 吐槽

## 继承和多态造成代码碎片化

看程序的时候，看到`ref->fn()`，你不知道fn()究竟是哪个函数，你得知道ref是怎么初始化的，是父类还是子类，才能找到正确的函数。
当你找到某个子类的fn()的实现，你会发现它还会调用父类的fn()，甚至太祖父类的fn()，这使得函数之间的关系更为复杂。

## 类型的缺失

C++中，类型是很重要的，现代C++的代码很容易写出一个很长的类型，比如：`std::list<xsdf::<xxx>::ref>`。
为了不重复写这么长的类型，当然要typedef
typedef多了之后，连自己都不知道这玩意是什么了。

# OOP or not



## 不使用OOP



### 使用全局函数代替ctor

还可以利用boost.LEAF库



# 异常

## 尽量不使用异常



## 可以使用异常的场景

1. ctor。没办法，只能使用。
2. 函数开始的不变式。invariant。
3. 必须在程序release之后还要保留的assert的地方。



## 不能使用异常的地方

1. 最外面的catch{}里面不能抛异常



## 谷歌

![img](https://ask.qcloudimg.com/developer-images/article/1198598/5mfdn24fw6.png)

## 如何抛出异常

1. 就地打印出错信息。这点和其他程序逻辑一样：在出错的地方打印错误日志
2. 抛出异常的目的
   1. 快速退出程序
   2. 提供足够的诊断信息，让程序员找bug
3. 抛出异常应该携带的信息
   1. exception的类型不重要
   2. exception本身的错误信息要简短
   3. exception本身要提供stacktrace
   4. cxception要提供：源码函数名、源码文件名、出错行号
